//! App trait for main applications.
//!
//! Apps are the primary unit of composition in rafter. Each app has:
//! - A view (`element() -> Element`)
//! - Keybinds
//! - Lifecycle hooks
//! - Event/request handlers

use std::any::{Any, TypeId};
use std::future::Future;
use std::pin::Pin;
use std::sync::OnceLock;

use tuidom::Element;

use crate::{AppContext, GlobalContext, HandlerRegistry, KeybindClosures, WakeupSender};

/// App configuration.
#[derive(Debug, Clone)]
pub struct AppConfig {
    /// Display name.
    pub name: &'static str,
    /// Behavior when this app loses focus.
    pub on_blur: BlurPolicy,
    /// Maximum number of instances (None = unlimited).
    pub max_instances: Option<usize>,
    /// Panic behavior.
    pub panic_behavior: PanicBehavior,
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            name: "App",
            on_blur: BlurPolicy::Continue,
            max_instances: None,
            panic_behavior: PanicBehavior::default(),
        }
    }
}

/// Panic behavior for an app.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub enum PanicBehavior {
    /// Close the app instance (default).
    #[default]
    Close,
    /// Restart with fresh state (requires Default).
    Restart,
    /// Ignore the panic and continue.
    Ignore,
}

/// Behavior when an app instance loses focus.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub enum BlurPolicy {
    /// Keep running in background (default).
    #[default]
    Continue,
    /// Pause event delivery, enter dormant state.
    Sleep,
    /// Close the instance when losing focus.
    Close,
}

/// Trait that all apps must implement.
///
/// Typically implemented via `#[app]` and `#[app_impl]` macros.
/// Apps use interior mutability - all methods take `&self`.
pub trait App: Clone + Send + Sync + 'static {
    /// Get the app configuration.
    fn config() -> AppConfig
    where
        Self: Sized,
    {
        AppConfig::default()
    }

    /// Get the app's display name.
    fn name(&self) -> &'static str {
        Self::config().name
    }

    /// Get the instance-specific title.
    fn title(&self) -> String {
        Self::config().name.to_string()
    }

    /// Get the app's keybinds (closure-based).
    fn keybinds(&self) -> KeybindClosures {
        KeybindClosures::new()
    }

    /// Get the handler registry for widget events.
    fn handlers(&self) -> &HandlerRegistry {
        static EMPTY: OnceLock<HandlerRegistry> = OnceLock::new();
        EMPTY.get_or_init(HandlerRegistry::new)
    }

    /// Render the app's view.
    fn element(&self) -> Element;

    /// Get current page identifier for keybind scoping.
    fn current_page(&self) -> Option<String> {
        None
    }

    // =========================================================================
    // Lifecycle
    // =========================================================================

    /// Called when the app starts.
    fn on_start(&self) -> impl Future<Output = ()> + Send {
        async {}
    }

    /// Called when the instance gains focus.
    fn on_foreground(&self) -> impl Future<Output = ()> + Send {
        async {}
    }

    /// Called when the instance loses focus.
    fn on_background(&self) -> impl Future<Output = ()> + Send {
        async {}
    }

    /// Called before close. Return false to cancel.
    fn on_close_request(&self) -> bool {
        true
    }

    /// Called during cleanup after close is confirmed.
    fn on_close(&self) -> impl Future<Output = ()> + Send {
        async {}
    }

    // =========================================================================
    // State Management
    // =========================================================================

    /// Get the panic behavior.
    fn panic_behavior(&self) -> PanicBehavior {
        PanicBehavior::default()
    }

    /// Check if any state is dirty and needs re-render.
    fn is_dirty(&self) -> bool {
        true
    }

    /// Clear dirty flags after render.
    fn clear_dirty(&self) {}

    /// Install wakeup sender on all State fields.
    fn install_wakeup(&self, sender: WakeupSender) {
        let _ = sender;
    }

    // =========================================================================
    // Event/Request Dispatch (generated by macros)
    // =========================================================================

    /// Dispatch an event. Returns true if handled.
    fn dispatch_event(
        &self,
        event_type: TypeId,
        event: Box<dyn Any + Send + Sync>,
        cx: &AppContext,
        gx: &GlobalContext,
    ) -> bool {
        let _ = (event_type, event, cx, gx);
        false
    }

    /// Dispatch a request. Returns future if handler exists.
    fn dispatch_request(
        &self,
        request_type: TypeId,
        request: Box<dyn Any + Send + Sync>,
        cx: &AppContext,
        gx: &GlobalContext,
    ) -> Option<Pin<Box<dyn Future<Output = Box<dyn Any + Send + Sync>> + Send>>> {
        let _ = (request_type, request, cx, gx);
        None
    }

    /// Check if this app has a handler for the event type.
    fn has_event_handler(&self, event_type: TypeId) -> bool {
        let _ = event_type;
        false
    }

    /// Check if this app has a handler for the request type.
    fn has_request_handler(&self, request_type: TypeId) -> bool {
        let _ = request_type;
        false
    }
}
