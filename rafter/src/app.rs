//! App trait for main applications.
//!
//! Apps are the primary unit of composition in rafter. Each app has:
//! - A view (`page() -> Element`)
//! - Keybinds
//! - Lifecycle hooks
//! - Event/request handlers

use std::any::{Any, TypeId};
use std::future::Future;
use std::pin::Pin;

use tuidom::Element;

use crate::{HandlerId, Keybinds, WakeupSender};

/// App configuration.
#[derive(Debug, Clone)]
pub struct AppConfig {
    /// Display name.
    pub name: &'static str,
    /// Whether to blur the app when it loses focus.
    pub blur_on_background: bool,
    /// Maximum number of instances (None = unlimited).
    pub max_instances: Option<usize>,
    /// Panic behavior.
    pub panic_behavior: PanicBehavior,
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            name: "App",
            blur_on_background: false,
            max_instances: None,
            panic_behavior: PanicBehavior::default(),
        }
    }
}

/// Panic behavior for an app.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub enum PanicBehavior {
    /// Close the app instance (default).
    #[default]
    Close,
    /// Restart with fresh state (requires Default).
    Restart,
    /// Ignore the panic and continue.
    Ignore,
}

/// Trait that all apps must implement.
///
/// Typically implemented via `#[app]` and `#[app_impl]` macros.
/// Apps use interior mutability - all methods take `&self`.
pub trait App: Clone + Send + Sync + 'static {
    /// Get the app configuration.
    fn config() -> AppConfig
    where
        Self: Sized,
    {
        AppConfig::default()
    }

    /// Get the app's display name.
    fn name(&self) -> &'static str {
        Self::config().name
    }

    /// Get the instance-specific title.
    fn title(&self) -> String {
        Self::config().name.to_string()
    }

    /// Get the app's keybinds.
    fn keybinds(&self) -> Keybinds {
        Keybinds::new()
    }

    /// Render the app's page.
    fn page(&self) -> Element;

    /// Get current page identifier for keybind scoping.
    fn current_page(&self) -> Option<String> {
        None
    }

    // =========================================================================
    // Lifecycle
    // =========================================================================

    /// Called when the app starts.
    fn on_start(&self) -> impl Future<Output = ()> + Send {
        async {}
    }

    /// Called when the instance gains focus.
    fn on_foreground(&self) -> impl Future<Output = ()> + Send {
        async {}
    }

    /// Called when the instance loses focus.
    fn on_background(&self) -> impl Future<Output = ()> + Send {
        async {}
    }

    /// Called before close. Return false to cancel.
    fn on_close_request(&self) -> bool {
        true
    }

    /// Called during cleanup after close is confirmed.
    fn on_close(&self) -> impl Future<Output = ()> + Send {
        async {}
    }

    // =========================================================================
    // State Management
    // =========================================================================

    /// Get the panic behavior.
    fn panic_behavior(&self) -> PanicBehavior {
        PanicBehavior::default()
    }

    /// Check if any state is dirty and needs re-render.
    fn is_dirty(&self) -> bool {
        true
    }

    /// Clear dirty flags after render.
    fn clear_dirty(&self) {}

    /// Install wakeup sender on all State fields.
    fn install_wakeup(&self, sender: WakeupSender) {
        let _ = sender;
    }

    // =========================================================================
    // Dispatch (generated by macros)
    // =========================================================================

    /// Dispatch a handler by ID.
    fn dispatch(&self, handler_id: &HandlerId) {
        log::warn!("No dispatch implementation for handler '{}'", handler_id.0);
    }

    /// Dispatch an event. Returns true if handled.
    fn dispatch_event(
        &self,
        event_type: TypeId,
        event: Box<dyn Any + Send + Sync>,
    ) -> bool {
        let _ = (event_type, event);
        false
    }

    /// Dispatch a request. Returns future if handler exists.
    fn dispatch_request(
        &self,
        request_type: TypeId,
        request: Box<dyn Any + Send + Sync>,
    ) -> Option<Pin<Box<dyn Future<Output = Box<dyn Any + Send + Sync>> + Send>>> {
        let _ = (request_type, request);
        None
    }

    /// Check if this app has a handler for the event type.
    fn has_event_handler(&self, event_type: TypeId) -> bool {
        let _ = event_type;
        false
    }

    /// Check if this app has a handler for the request type.
    fn has_request_handler(&self, request_type: TypeId) -> bool {
        let _ = request_type;
        false
    }
}
