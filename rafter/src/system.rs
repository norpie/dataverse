//! System trait for global keybinds and optional overlays.
//!
//! Systems are like invisible apps - they have keybinds and handlers.
//! Optionally, they can have a visual overlay (taskbar, status bar, etc.).

use std::any::{Any, TypeId};
use std::future::Future;
use std::pin::Pin;

use tuidom::Element;

use crate::{GlobalContext, HandlerRegistry, KeybindClosures, LifecycleHooks, WakeupSender};

/// Position configuration for a system overlay.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OverlayPosition {
    /// Fixed to the top edge, shrinks app area.
    Top { height: u16 },
    /// Fixed to the bottom edge, shrinks app area.
    Bottom { height: u16 },
    /// Fixed to the left edge, shrinks app area.
    Left { width: u16 },
    /// Fixed to the right edge, shrinks app area.
    Right { width: u16 },
    /// Absolute position, renders on top without affecting layout.
    Absolute {
        x: u16,
        y: u16,
        width: u16,
        height: u16,
    },
}

impl OverlayPosition {
    /// Returns true if this is an edge overlay (affects app layout).
    pub fn is_edge(&self) -> bool {
        !matches!(self, Self::Absolute { .. })
    }

    /// Returns true if this overlay should be prepended to focus order.
    pub fn prepend_focus(&self) -> bool {
        matches!(self, Self::Top { .. } | Self::Left { .. })
    }
}

/// A system overlay with position and content.
#[derive(Debug)]
pub struct Overlay {
    pub position: OverlayPosition,
    pub element: Element,
}

impl Overlay {
    pub fn new(position: OverlayPosition, element: Element) -> Self {
        Self { position, element }
    }

    pub fn top(height: u16, element: Element) -> Self {
        Self::new(OverlayPosition::Top { height }, element)
    }

    pub fn bottom(height: u16, element: Element) -> Self {
        Self::new(OverlayPosition::Bottom { height }, element)
    }

    pub fn left(width: u16, element: Element) -> Self {
        Self::new(OverlayPosition::Left { width }, element)
    }

    pub fn right(width: u16, element: Element) -> Self {
        Self::new(OverlayPosition::Right { width }, element)
    }

    pub fn absolute(x: u16, y: u16, width: u16, height: u16, element: Element) -> Self {
        Self::new(
            OverlayPosition::Absolute { x, y, width, height },
            element,
        )
    }
}

/// Trait for systems (global keybinds with optional visual overlay).
///
/// Typically implemented via `#[system]` and `#[system_impl]` macros.
///
/// Systems without overlay just handle keybinds.
/// Systems with overlay also render a persistent UI element.
pub trait System: Clone + Send + Sync + 'static {
    /// Get the system's display name.
    fn name(&self) -> &'static str;

    /// Get the system's keybinds (closure-based).
    fn keybinds(&self) -> KeybindClosures {
        KeybindClosures::new()
    }

    /// Get the handler registry for page! macro integration.
    fn handlers(&self) -> &HandlerRegistry {
        static EMPTY: std::sync::OnceLock<HandlerRegistry> = std::sync::OnceLock::new();
        EMPTY.get_or_init(HandlerRegistry::new)
    }

    // =========================================================================
    // Overlay (optional)
    // =========================================================================

    /// Get the overlay. Return None for keybinds-only system.
    fn overlay(&self) -> Option<Overlay> {
        None
    }

    /// Get lifecycle hook closures.
    ///
    /// Override via `#[on_start]` attribute in `#[system_impl]`.
    fn lifecycle_hooks(&self) -> LifecycleHooks {
        LifecycleHooks::new()
    }

    // =========================================================================
    // State Management
    // =========================================================================

    /// Check if the overlay needs re-rendering.
    fn is_dirty(&self) -> bool {
        true
    }

    /// Clear dirty flags after rendering.
    fn clear_dirty(&self) {}

    /// Install wakeup sender for state change notifications.
    fn install_wakeup(&self, sender: WakeupSender) {
        let _ = sender;
    }

    // =========================================================================
    // Event/Request Dispatch (generated by macros)
    // =========================================================================

    /// Check if this system has a handler for the event type.
    fn has_event_handler(&self, event_type: TypeId) -> bool {
        let _ = event_type;
        false
    }

    /// Check if this system has a handler for the request type.
    fn has_request_handler(&self, request_type: TypeId) -> bool {
        let _ = request_type;
        false
    }

    /// Dispatch an event. Returns true if handled.
    fn dispatch_event(
        &self,
        event_type: TypeId,
        event: &(dyn Any + Send + Sync),
        gx: &GlobalContext,
    ) -> bool {
        let _ = (event_type, event, gx);
        false
    }

    /// Dispatch a request. Returns future if handler exists.
    fn dispatch_request(
        &self,
        request_type: TypeId,
        request: Box<dyn Any + Send + Sync>,
        gx: &GlobalContext,
    ) -> Option<Pin<Box<dyn Future<Output = Box<dyn Any + Send + Sync>> + Send>>> {
        let _ = (request_type, request, gx);
        None
    }
}
