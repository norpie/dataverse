//! Handler generation for the page! macro.
//!
//! Generates handler insertions into WidgetHandlers maps.
//! Each handler becomes a closure inserted into the map,
//! which calls the wrapper method generated by #[app_impl] / #[modal_impl].

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::macros::page::ast::{HandlerArg, HandlerAttr};

/// Generate handler insertions into a WidgetHandlers map.
///
/// Each handler becomes an insertion like:
/// ```ignore
/// {
///     let __self = self.clone();
///     let __arg0 = (arg0_expr).clone();
///     __handlers.insert(
///         "on_activate",
///         std::sync::Arc::new(move |__hx: &rafter::HandlerContext| {
///             __self.__wrap_handler(__arg0.clone(), __hx);
///         }),
///     );
/// }
/// ```
///
/// Returns a TokenStream with all insertion blocks.
pub fn generate_handler_insertions(handlers: &[HandlerAttr]) -> TokenStream {
    let insertions: Vec<TokenStream> = handlers.iter().map(generate_single_insertion).collect();

    quote! { #(#insertions)* }
}

/// Generate a single handler insertion block
fn generate_single_insertion(handler: &HandlerAttr) -> TokenStream {
    let event_str = handler.event.to_string();
    let handler_name = &handler.handler;
    let wrapper_method = format_ident!("__wrap_{}", handler_name);

    // Collect non-context arguments
    let expr_args: Vec<_> = handler
        .args
        .iter()
        .filter_map(|arg| match arg {
            HandlerArg::Expr(expr) => Some(expr),
            HandlerArg::Context(_) => None,
        })
        .collect();

    // Generate argument captures
    let arg_captures: Vec<TokenStream> = expr_args
        .iter()
        .enumerate()
        .map(|(i, expr)| {
            let arg_name = format_ident!("__arg{}", i);
            quote! { let #arg_name = (#expr).clone(); }
        })
        .collect();

    // Generate argument passes to wrapper (with .clone() for the move closure)
    let arg_passes: Vec<TokenStream> = (0..expr_args.len())
        .map(|i| {
            let arg_name = format_ident!("__arg{}", i);
            quote! { #arg_name.clone() }
        })
        .collect();

    // Build the wrapper call
    let wrapper_call = if arg_passes.is_empty() {
        quote! { __self.#wrapper_method(__hx); }
    } else {
        quote! { __self.#wrapper_method(#(#arg_passes),*, __hx); }
    };

    quote! {
        {
            let __self = self.clone();
            #(#arg_captures)*
            __handlers.insert(
                #event_str,
                std::sync::Arc::new(move |__hx: &rafter::HandlerContext| {
                    #wrapper_call
                }),
            );
        }
    }
}

/// Generate handler registration blocks for a widget (legacy, for containers).
///
/// Each handler becomes a registration like:
/// ```ignore
/// {
///     let __self = self.clone();
///     let __arg0 = (arg0_expr).clone();
///     self.__handler_registry.register(
///         __elem.id(),
///         "on_click",
///         std::sync::Arc::new(move |__hx: &rafter::HandlerContext| {
///             __self.__wrap_handler(__arg0.clone(), __hx);
///         }),
///     );
/// }
/// ```
///
/// Returns a TokenStream with all registration blocks.
pub fn generate_handler_registrations(handlers: &[HandlerAttr]) -> TokenStream {
    let registrations: Vec<TokenStream> = handlers
        .iter()
        .map(generate_single_registration)
        .collect();

    quote! { #(#registrations)* }
}

/// Generate a single handler registration block
fn generate_single_registration(handler: &HandlerAttr) -> TokenStream {
    let event_str = handler.event.to_string();
    let handler_name = &handler.handler;
    let wrapper_method = format_ident!("__wrap_{}", handler_name);

    // Collect non-context arguments
    let expr_args: Vec<_> = handler
        .args
        .iter()
        .filter_map(|arg| match arg {
            HandlerArg::Expr(expr) => Some(expr),
            HandlerArg::Context(_) => None,
        })
        .collect();

    // Generate argument captures
    let arg_captures: Vec<TokenStream> = expr_args
        .iter()
        .enumerate()
        .map(|(i, expr)| {
            let arg_name = format_ident!("__arg{}", i);
            quote! { let #arg_name = (#expr).clone(); }
        })
        .collect();

    // Generate argument passes to wrapper (with .clone() for the move closure)
    let arg_passes: Vec<TokenStream> = (0..expr_args.len())
        .map(|i| {
            let arg_name = format_ident!("__arg{}", i);
            quote! { #arg_name.clone() }
        })
        .collect();

    // Build the wrapper call
    let wrapper_call = if arg_passes.is_empty() {
        quote! { __self.#wrapper_method(__hx); }
    } else {
        quote! { __self.#wrapper_method(#(#arg_passes),*, __hx); }
    };

    quote! {
        {
            let __self = self.clone();
            #(#arg_captures)*
            self.__handler_registry.register(
                &__elem.id,
                #event_str,
                std::sync::Arc::new(move |__hx: &rafter::HandlerContext| {
                    #wrapper_call
                }),
            );
        }
    }
}
